import com.comsol.model.*;
import com.comsol.model.util.*;
import java.lang.Math;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * COMSOL Multiphysics simulation for lattice structure elastic properties.
 * Generated from template.
 */
public class {{ class_name }} {

    // Simulation constants
    private static final int NUM_TABLES = 3;
    private static final int NUM_PROBES = 9;
    private static final int MAX_ANIMATION_FRAMES = 100;
    private static final int ANIMATION_FPS = 20;

    // Component names
    private static final String COMPONENT_NAME = "comp1";
    private static final String GEOMETRY_NAME = "geom1";
    private static final String PHYSICS_NAME = "solid";
    private static final String MESH_NAME = "mesh1";
    private static final String MATERIAL_NAME = "mat1";

    // Study and solver names
    private static final String STUDY_NAME = "std1";
    private static final String SOLUTION_NAME = "sol1";
    private static final String BATCH_NAME = "p1";

    // Selection names
    private static final String UNION_NAME = "uni1";
    private static final String DIFFERENCE_1 = "dif1";
    private static final String DIFFERENCE_2 = "dif2";

    // Precision constants
    private static final double EPSILON = 1e-10;
    private static final int ROUND_PRECISION = 1000;

    /**
     * Main simulation entry point.
     */
    public static Model run() {
        // 1. Initialize simulation parameters
        String file = "{{ file_name }}";
        String path = "{{ output_path }}";
        String stlfile = "{{ stl_path }}";
        Path output = Paths.get(path);

        double lconst = {{ lattice_constant }};
        double pratio = {{ poisson_ratio }} / 100.0;
        String[] dstep = new String[]{ {{ dstep }} };
        double delta = {{ delta }};

        double rs = {{ sphere_radius_ratio }} / 100.0;
        double rb = {{ bond_radius_ratio }} / 100.0;

        String latticeType = "{{ lattice_type }}";
        double shift = {{ shift }};

        // 2. Calculate lattice structure geometry (cubic cell: 2x2x2 for proper visualization)
        double[][] e = basis(lconst, lconst, lconst, 90.0, 90.0, 90.0);
        double[][] loc = getLatticeTypeLocations(latticeType);
        double[] dMinMax = getLatticeTypeBondLengths(latticeType, lconst);
        double dMin = dMinMax[0];
        double dMax = dMinMax[1];

        loc = translatePoints(loc, shift);

        // Create cubic cell (2x2x2 lattice points)
        // FCC: 8 corner atoms (1/8 each) + 6 face-centered atoms (1/2 each) = 4 atoms total
        double[][] points = lattice_points(e, loc, 2, 2, 2);
        double[][][] lines = select_bonds(points, dMin, dMax);

        // Cubic cell size is 2x the lattice constant
        double[] uniSize = new double[]{2.0 * lconst, 2.0 * lconst, 2.0 * lconst};

        // 3. Calculate rotation matrices for strain application
        double[][] rotate1 = calculateRotationMatrix();
        double[][] rotate1_ = transpose(rotate1);

        // 4. Create COMSOL model
        Model model = createModel(file, path);

        // 5. Setup model components
        setupModelParameters(model, lconst, rs, rb, delta, uniSize);
        createResultTables(model);

        // 6. Build geometry
        model = buildGeometry(model, uniSize, points, lines);

        // 7. Setup simulation components
        setupProbes(model);
        setupCouplingOperators(model);
        setupMesh(model);
        setupPhysics(model, pratio);
        configureProbes(model);

        // 8. Setup and run study
        setupStudy(model, dstep, delta, rotate1, rotate1_);
        setupSolver(model, dstep);
        setupBatchJob(model, delta, rotate1, rotate1_);

        // 9. Execute and export results
        runBatchAndExportResults(model, file, output);
        setupVisualization(model, file, output);

        return model;
    }

    /* ========== Lattice Structure Calculation ========== */

    private static double[][] getLatticeTypeLocations(String latticeType) {
        if (latticeType.equals("fcc")) {
            return new double[][]{% raw %}{{0,0,0}, {0,.5,.5}, {.5,0,.5}, {.5,.5,0}}{% endraw %};
        } else if (latticeType.equals("dia")) {
            return new double[][]{
                {% raw %}{0,0,0}, {0,.5,.5}, {.5,0,.5}, {.5,.5,0},
                {0.25,0.25,0.25}, {0.25,0.75,0.75}, {0.75,0.25,0.75}, {0.75,0.75,0.25}{% endraw %}
            };
        } else if (latticeType.equals("bcc")) {
            return new double[][]{% raw %}{{0,0,0}, {.5,.5,.5}}{% endraw %};
        } else if (latticeType.equals("simple")) {
            return new double[][]{% raw %}{{0,0,0}}{% endraw %};
        } else {
            return new double[][]{% raw %}{{0,0,0}}{% endraw %};
        }
    }

    private static double[] getLatticeTypeBondLengths(String latticeType, double lconst) {
        double[] dMinMax = new double[2];

        if (latticeType.equals("fcc")) {
            dMinMax[0] = 0.7 * lconst;
            dMinMax[1] = 0.71 * lconst;
        } else if (latticeType.equals("dia")) {
            dMinMax[0] = 0.4 * lconst;
            dMinMax[1] = 0.45 * lconst;
        } else if (latticeType.equals("bcc")) {
            dMinMax[0] = 0.8 * lconst;
            dMinMax[1] = 0.9 * lconst;
        } else if (latticeType.equals("simple")) {
            dMinMax[0] = 0.9 * lconst;
            dMinMax[1] = 1.1 * lconst;
        } else {
            dMinMax[0] = {{ d_min }};
            dMinMax[1] = {{ d_max }};
        }

        return dMinMax;
    }

    private static double[][] calculateRotationMatrix() {
        // Default identity rotation (can be changed to 111 or other orientations)
        double[][] rotate = new double[][]{% raw %}{{1.,0.,0.}, {0.,1.,0.}, {0.,0.,1.}}{% endraw %};
        return unit_tensor(rotate);
    }

    /* ========== Model Creation and Configuration ========== */

    private static Model createModel(String file, String path) {
        Model model = ModelUtil.create("Model");
        model.modelPath(path);
        model.label(file + ".mph");
        model.component().create(COMPONENT_NAME, true);
        return model;
    }

    private static void setupModelParameters(Model model, double lconst, double rs, double rb, double delta, double[] uniSize) {
        model.param().set("disp", "0");
        model.param().set("Lx", uniSize[0] + "[mm]");
        model.param().set("Ly", uniSize[1] + "[mm]");
        model.param().set("Lz", uniSize[2] + "[mm]");
        model.param().set("lconst", lconst + "[mm]");
        model.param().set("Rs", rs);
        model.param().set("Rb", rb);

        // Strain tensor components (initialized to 1)
        String[] strainParams = {"E11", "E21", "E31", "E12", "E22", "E32", "E13", "E23", "E33"};
        for (String param : strainParams) {
            model.param().set(param, 1);
        }
        model.param().set("delta", delta);
    }

    private static void createResultTables(Model model) {
        for (int i = 1; i < NUM_TABLES; i++) {
            model.result().table().create("tbl" + i, "Table");
            model.result().table("tbl" + i).label("Maximum mises stress " + i);
        }
        model.result().table().create("tbl" + NUM_TABLES, "Table");
        model.result().table("tbl" + NUM_TABLES).label("Probe Table");
    }

    /* ========== Geometry Construction ========== */

    private static Model buildGeometry(Model model, double[] uniSize, double[][] points, double[][][] lines) {
        model.component(COMPONENT_NAME).geom().create(GEOMETRY_NAME, 3);
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).lengthUnit("mm");

        createSpheres(model, points);
        createBonds(model, points.length, lines);
        createLatticeUnion(model, points.length, lines.length);
        createUnitCell(model, uniSize);
        createBoundarySelections(model);

        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).run();
        return model;
    }

    private static void createLatticeUnion(Model model, int numSpheres, int numBonds) {
        // Create union of all spheres and bonds
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(UNION_NAME, "Union");

        // Add all spheres
        String[] objects = new String[numSpheres + numBonds];
        for (int i = 0; i < numSpheres; i++) {
            objects[i] = "sph" + i;
        }

        // Add all bonds
        for (int j = 0; j < numBonds; j++) {
            objects[numSpheres + j] = "swp" + j;
        }

        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(UNION_NAME).selection("input").set(objects);
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(UNION_NAME).set("intbnd", false);
    }

    private static void createSpheres(Model model, double[][] points) {
        for (int i = 0; i < points.length; i++) {
            String sph = "sph" + i;
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(sph, "Sphere");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(sph).set("pos", points[i]);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(sph).set("r", "Rs");
        }
    }

    private static void createBonds(Model model, int pointCount, double[][][] lines) {
        for (int j = 0; j < lines.length; j++) {
            double[][] l = lines[j];
            String lll = "lin" + j;

            // Create line segment
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(lll, "LineSegment");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(lll).set("specify1", "coord");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(lll).set("specify2", "coord");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(lll).set("coord1", l[0]);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(lll).set("coord2", l[1]);

            // Calculate line direction
            double[] ln = new double[]{l[1][0] - l[0][0], l[1][1] - l[0][1], l[1][2] - l[0][2]};

            // Create work plane perpendicular to bond
            String wp = "wp" + j;
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(wp, "WorkPlane");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(wp).set("unite", true);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(wp).set("planetype", "normalvector");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(wp).set("normalvector", ln);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(wp).set("normalcoord", l[0]);

            // Create circle on work plane
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(wp).geom().create("c1", "Circle");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(wp).geom().feature("c1").set("r", "Rb");

            // Sweep circle along line to create cylindrical bond
            String swp = "swp" + j;
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(swp, "Sweep");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(swp).set("crossfaces", true);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(swp).set("includefinal", false);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(swp).selection("face").set(wp + ".c1", 1);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(swp).selection("edge").set(lll + "(1)", 1);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(swp).selection("diredge").set(lll + "(1)", 1);
        }
    }

    private static void createUnitCell(Model model, double[] uniSize) {
        // Create first block
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create("blk0", "Block");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("blk0").set("pos", new double[]{0., 0., 0.});
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("blk0").set("size", uniSize);

        // Subtract lattice structure from block
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(DIFFERENCE_1, "Difference");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(DIFFERENCE_1).selection("input").set("blk0");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(DIFFERENCE_1).selection("input2").set(UNION_NAME);

        // Create second block for final geometry
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create("blk1", "Block");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("blk1").set("pos", new double[]{0., 0., 0.});
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("blk1").set("size", uniSize);

        // Get porous structure
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(DIFFERENCE_2, "Difference");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(DIFFERENCE_2).selection("input").set("blk1");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(DIFFERENCE_2).selection("input2").set(DIFFERENCE_1);
    }

    private static void createBoundarySelections(Model model) {
        String[][] boundaries = {
            {"boxsel1", "edgeXn", "xmin", "-eps", "xmax", "eps"},
            {"boxsel2", "edgeXp", "xmin", "Lx-eps", "xmax", "Lx+eps"},
            {"boxsel3", "edgeYn", "ymin", "-eps", "ymax", "eps"},
            {"boxsel4", "edgeYp", "ymin", "Ly-eps", "ymax", "Ly+eps"},
            {"boxsel5", "edgeZn", "zmin", "-eps", "zmax", "eps"},
            {"boxsel6", "edgeZp", "zmin", "Lz-eps", "zmax", "Lz+eps"}
        };

        for (String[] bounds : boundaries) {
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create(bounds[0], "BoxSelection");
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(bounds[0]).set("entitydim", 2);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(bounds[0]).label(bounds[1]);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(bounds[0]).set(bounds[2], bounds[3]);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(bounds[0]).set(bounds[4], bounds[5]);
            model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature(bounds[0]).set("condition", "inside");
        }

        // Fixed point boundary
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).create("boxsel7", "BoxSelection");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("entitydim", 0);
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").label("edgePoint");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("xmin", "-eps");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("xmax", "+eps");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("ymin", "-eps");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("ymax", "+eps");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("zmin", "-eps");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("zmax", "+eps");
        model.component(COMPONENT_NAME).geom(GEOMETRY_NAME).feature("boxsel7").set("condition", "inside");
    }

    /* ========== Probes and Coupling ========== */

    private static void setupProbes(Model model) {
        for (int i = 1; i <= NUM_PROBES; i++) {
            model.component(COMPONENT_NAME).probe().create("dom" + i, "Domain");
        }
    }

    private static void setupCouplingOperators(Model model) {
        String[][] couplings = {
            {"genext1", "coupleX", GEOMETRY_NAME + "_boxsel1", "X-Lx", "Y", "Z"},
            {"genext2", "coupleY", GEOMETRY_NAME + "_boxsel3", "X", "Y-Ly", "Z"},
            {"genext3", "coupleZ", GEOMETRY_NAME + "_boxsel5", "X", "Y", "Z-Lz"}
        };

        for (String[] cpl : couplings) {
            model.component(COMPONENT_NAME).cpl().create(cpl[0], "GeneralExtrusion");
            model.component(COMPONENT_NAME).cpl(cpl[0]).selection().named(cpl[2]);
            model.component(COMPONENT_NAME).cpl(cpl[0]).label(cpl[1]);
            model.component(COMPONENT_NAME).cpl(cpl[0]).set("opname", cpl[1]);
            model.component(COMPONENT_NAME).cpl(cpl[0]).set("srcframe", "material");
            model.component(COMPONENT_NAME).cpl(cpl[0]).set("dstmap", new String[]{cpl[3], cpl[4], cpl[5]});
        }

        model.component(COMPONENT_NAME).cpl().create("maxop1", "Maximum");
        model.component(COMPONENT_NAME).cpl("maxop1").selection().set(1);
    }

    private static void configureProbes(Model model) {
        String[][] probeConfig = {
            {"dom1", "P11", "-" + PHYSICS_NAME + ".PxX"}, {"dom2", "P21", "-" + PHYSICS_NAME + ".PyX"}, {"dom3", "P31", "-" + PHYSICS_NAME + ".PzX"},
            {"dom4", "P12", "-" + PHYSICS_NAME + ".PxY"}, {"dom5", "P22", "-" + PHYSICS_NAME + ".PyY"}, {"dom6", "P32", "-" + PHYSICS_NAME + ".PzY"},
            {"dom7", "P13", "-" + PHYSICS_NAME + ".PxZ"}, {"dom8", "P23", "-" + PHYSICS_NAME + ".PyZ"}, {"dom9", "P33", "-" + PHYSICS_NAME + ".PzZ"}
        };

        for (String[] cfg : probeConfig) {
            model.component(COMPONENT_NAME).probe(cfg[0]).label(cfg[1]);
            model.component(COMPONENT_NAME).probe(cfg[0]).set("probename", cfg[1]);
            model.component(COMPONENT_NAME).probe(cfg[0]).set("expr", cfg[2]);
            model.component(COMPONENT_NAME).probe(cfg[0]).set("unit", "MPa");
            model.component(COMPONENT_NAME).probe(cfg[0]).set("table", "tbl" + NUM_TABLES);
            model.component(COMPONENT_NAME).probe(cfg[0]).set("window", "window1");
        }
    }

    /* ========== Mesh Setup ========== */

    private static void setupMesh(Model model) {
        model.component(COMPONENT_NAME).coordSystem("sys1").label("Boundary System 1");
        model.component(COMPONENT_NAME).mesh().create(MESH_NAME);
        model.component(COMPONENT_NAME).mesh(MESH_NAME).autoMeshSize(5);

        // Free triangular mesh on periodic boundaries
        String[] ftriNames = {"ftri1", "ftri2", "ftri3"};
        String[] boxSelNames = {GEOMETRY_NAME + "_boxsel1", GEOMETRY_NAME + "_boxsel3", GEOMETRY_NAME + "_boxsel5"};

        for (int i = 0; i < 3; i++) {
            model.component(COMPONENT_NAME).mesh(MESH_NAME).create(ftriNames[i], "FreeTri");
            model.component(COMPONENT_NAME).mesh(MESH_NAME).feature(ftriNames[i]).selection().named(boxSelNames[i]);
        }

        // Copy mesh to opposite boundaries with proper mapping
        String[][] copyPairs = {
            {"cpf1", GEOMETRY_NAME + "_boxsel1", GEOMETRY_NAME + "_boxsel2", "Lx", "0", "0"},  // X direction
            {"cpf2", GEOMETRY_NAME + "_boxsel3", GEOMETRY_NAME + "_boxsel4", "0", "Ly", "0"},  // Y direction
            {"cpf3", GEOMETRY_NAME + "_boxsel5", GEOMETRY_NAME + "_boxsel6", "0", "0", "Lz"}   // Z direction
        };

        for (String[] pair : copyPairs) {
            model.component(COMPONENT_NAME).mesh(MESH_NAME).create(pair[0], "CopyFace");
            model.component(COMPONENT_NAME).mesh(MESH_NAME).feature(pair[0]).selection("source").named(pair[1]);
            model.component(COMPONENT_NAME).mesh(MESH_NAME).feature(pair[0]).selection("destination").named(pair[2]);
            // Set the displacement vector for the copy operation
            model.component(COMPONENT_NAME).mesh(MESH_NAME).feature(pair[0]).set("displx", pair[3]);
            model.component(COMPONENT_NAME).mesh(MESH_NAME).feature(pair[0]).set("disply", pair[4]);
            model.component(COMPONENT_NAME).mesh(MESH_NAME).feature(pair[0]).set("displz", pair[5]);
        }

        // Tetrahedral volume mesh
        model.component(COMPONENT_NAME).mesh(MESH_NAME).create("ftet1", "FreeTet");
        model.component(COMPONENT_NAME).mesh(MESH_NAME).run();
    }

    /* ========== Physics Setup ========== */

    private static void setupPhysics(Model model, double pratio) {
        // Material properties
        model.component(COMPONENT_NAME).material().create(MATERIAL_NAME, "Common");
        model.component(COMPONENT_NAME).material(MATERIAL_NAME).propertyGroup("def").set("density", "950");
        model.component(COMPONENT_NAME).material(MATERIAL_NAME).propertyGroup("def").set("poissonsratio", pratio + "-eps");
        model.component(COMPONENT_NAME).material(MATERIAL_NAME).propertyGroup("def").set("youngsmodulus", "10[MPa]");

        // Solid mechanics physics
        model.component(COMPONENT_NAME).physics().create(PHYSICS_NAME, "SolidMechanics", GEOMETRY_NAME);

        // Fixed boundary condition
        model.component(COMPONENT_NAME).physics(PHYSICS_NAME).create("fix1", "Fixed", 0);
        model.component(COMPONENT_NAME).physics(PHYSICS_NAME).feature("fix1").selection().named(GEOMETRY_NAME + "_boxsel7");

        // Periodic displacement boundary conditions
        setupPeriodicBoundaryConditions(model);
    }

    private static void setupPeriodicBoundaryConditions(Model model) {
        String[][] periodicBC = {
            {"disp1", GEOMETRY_NAME + "_boxsel2", "periodicX", "coupleX", "E11", "E21", "E31", "X"},
            {"disp2", GEOMETRY_NAME + "_boxsel4", "periodicY", "coupleY", "E12", "E22", "E32", "Y"},
            {"disp3", GEOMETRY_NAME + "_boxsel6", "periodicZ", "coupleZ", "E13", "E23", "E33", "Z"}
        };

        for (String[] bc : periodicBC) {
            model.component(COMPONENT_NAME).physics(PHYSICS_NAME).create(bc[0], "Displacement2", 2);
            model.component(COMPONENT_NAME).physics(PHYSICS_NAME).feature(bc[0]).selection().named(bc[1]);
            model.component(COMPONENT_NAME).physics(PHYSICS_NAME).feature(bc[0]).set("Direction", new int[][]{% raw %}{{1}, {1}, {1}}{% endraw %});
            model.component(COMPONENT_NAME).physics(PHYSICS_NAME).feature(bc[0])
                 .set("U0", new String[][]{% raw %}{{  bc[3]+"(u) - "+bc[4]+" * "+bc[7]+" * disp"},
                                            {bc[3]+"(v) - "+bc[5]+" * "+bc[7]+" * disp"},
                                            {bc[3]+"(w) - "+bc[6]+" * "+bc[7]+" * disp"}}{% endraw %});
            model.component(COMPONENT_NAME).physics(PHYSICS_NAME).feature(bc[0]).label(bc[2]);
        }
    }

    /* ========== Study and Solver Setup ========== */

    private static void setupStudy(Model model, String[] dstep, double delta, double[][] rotate1, double[][] rotate1_) {
        // Calculate strain parameters
        double[][] e33_ = rot(rotate1, rot(new double[][]{% raw %}{{0,0,0},{0,0,0},{0,0,1}}{% endraw %}, rotate1_));
        double[][] e31_ = rot(rotate1, rot(new double[][]{% raw %}{{0,0,0.5},{0,0,0},{0.5,0,0}}{% endraw %}, rotate1_));

        String[] strainParams = buildStrainParameters(e33_, e31_);

        // Create study
        model.study().create(STUDY_NAME);
        model.study(STUDY_NAME).setStoreSolution(true);
        model.study(STUDY_NAME).create("param", "Parametric");
        model.study(STUDY_NAME).create("stat", "Stationary");
        model.study(STUDY_NAME).label("Study 1");

        // Parametric sweep for strain tensor components
        model.study(STUDY_NAME).feature("param").label("Parametric Sweep");
        model.study(STUDY_NAME).feature("param").set("pname", new String[]{
            "E11", "E21", "E31", "E12", "E22", "E32", "E13", "E23", "E33"
        });
        model.study(STUDY_NAME).feature("param").set("plistarr", strainParams);
        model.study(STUDY_NAME).feature("param").set("punit", new String[]{"", "", "", "", "", "", "", "", ""});

        // Stationary study with geometric nonlinearity
        model.study(STUDY_NAME).feature("stat").label("Stationary");
        model.study(STUDY_NAME).feature("stat").set("geometricNonlinearity", true);
        model.study(STUDY_NAME).feature("stat").set("useparam", true);
        model.study(STUDY_NAME).feature("stat").set("pname", new String[]{"disp"});
        model.study(STUDY_NAME).feature("stat").set("plistarr", dstep);
        model.study(STUDY_NAME).feature("stat").set("punit", new String[]{""});
    }

    private static String[] buildStrainParameters(double[][] e33_, double[][] e31_) {
        String ddd = "*delta ";
        String[] params = new String[9];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                params[i * 3 + j] = e33_[i][j] + ddd + e31_[i][j] + ddd;
            }
        }
        return params;
    }

    private static void setupSolver(Model model, String[] dstep) {
        model.sol().create(SOLUTION_NAME);
        model.sol(SOLUTION_NAME).study(STUDY_NAME);
        model.sol(SOLUTION_NAME).attach(STUDY_NAME);
        model.sol(SOLUTION_NAME).create("st1", "StudyStep");
        model.sol(SOLUTION_NAME).create("v1", "Variables");
        model.sol(SOLUTION_NAME).create("s1", "Stationary");
        model.sol(SOLUTION_NAME).feature("s1").create("p1", "Parametric");
        model.sol(SOLUTION_NAME).feature("s1").create("fc1", "FullyCoupled");
        model.sol(SOLUTION_NAME).feature("s1").create("se1", "Segregated");
        model.sol(SOLUTION_NAME).feature("s1").feature().remove("fcDef");

        model.sol(SOLUTION_NAME).label("Solution 1");
        model.sol(SOLUTION_NAME).feature("v1").label("Dependent Variables 1");
        model.sol(SOLUTION_NAME).feature("v1").set("clistctrl", new String[]{"p1"});
        model.sol(SOLUTION_NAME).feature("v1").set("cname", new String[]{"disp"});
        model.sol(SOLUTION_NAME).feature("v1").set("clist", dstep);

        model.sol(SOLUTION_NAME).feature("s1").label("Stationary Solver 1");
        model.sol(SOLUTION_NAME).feature("s1").set("stol", "1e-7");
        model.sol(SOLUTION_NAME).feature("s1").set("reacf", false);
        model.sol(SOLUTION_NAME).feature("s1").set("probesel", "none");
        model.sol(SOLUTION_NAME).feature("s1").feature("dDef").set("ooc", false);
        model.sol(SOLUTION_NAME).feature("s1").feature("dDef").set("rhob", 400);
        model.sol(SOLUTION_NAME).feature("s1").feature("se1").set("segterm", "iter");
        model.sol(SOLUTION_NAME).feature("s1").feature("se1").set("plot", true);

        model.sol().create("sol2");
        model.sol("sol2").study(STUDY_NAME);
        model.sol("sol2").label("Parametric 1");
    }

    private static void setupBatchJob(Model model, double delta, double[][] rotate1, double[][] rotate1_) {
        double[][] e33_ = rot(rotate1, rot(new double[][]{% raw %}{{0,0,0},{0,0,0},{0,0,1}}{% endraw %}, rotate1_));
        double[][] e31_ = rot(rotate1, rot(new double[][]{% raw %}{{0,0,0.5},{0,0,0},{0.5,0,0}}{% endraw %}, rotate1_));

        String dd = "*delta";
        String[] strainParams = buildStrainParameters(e33_, e31_);

        model.batch().create(BATCH_NAME, "Parametric");
        model.batch(BATCH_NAME).study(STUDY_NAME);
        model.batch(BATCH_NAME).set("control", "param");
        model.batch(BATCH_NAME).set("pname", new String[]{
            "E11", "E21", "E31", "E12", "E22", "E32", "E13", "E23", "E33"
        });
        model.batch(BATCH_NAME).set("plistarr", strainParams);
        model.batch(BATCH_NAME).set("punit", new String[]{"", "", "", "", "", "", "", "", ""});
        model.batch(BATCH_NAME).set("err", true);
        model.batch(BATCH_NAME).attach(STUDY_NAME);
    }

    /* ========== Results and Export ========== */

    private static void runBatchAndExportResults(Model model, String file, Path output) {
        // Setup result datasets
        setupResultDatasets(model);

        // Run batch job
        model.batch(BATCH_NAME).run();

        // Configure and evaluate results
        configureNumericalEvaluations(model);

        // Export results to files
        exportKirchhoffStress(model, file, output);
        exportMaxMisesStress(model, file, output);
    }

    private static void setupResultDatasets(Model model) {
        model.result().dataset("dset1").set("probetag", "dom9");
        model.result().dataset().create("dset3", "Solution");
        model.result().dataset("dset2").set("probetag", "sol1");
        model.result().dataset("dset3").set("probetag", "sol2");

        for (int i = 1; i < NUM_TABLES; i++) {
            String dset = "dset" + (i + 3);
            model.result().dataset().create(dset, "Solution");
            model.result().dataset(dset).set("solution", "sol" + (i + 2));
            model.result().dataset(dset).label("max_mises" + i);
            model.result().numerical().create("gev" + i, "EvalGlobal");
        }

        for (int i = 1; i <= NUM_PROBES; i++) {
            model.result().dataset().create("avh" + i, "Average");
            model.result().dataset("avh" + i).set("probetag", "dom" + i);
            model.result().dataset("avh" + i).selection().geom("geom1", 3);
            model.result().dataset("avh" + i).selection().set(1);
            model.result().numerical().create("pev" + i, "EvalPoint");
            model.result().numerical("pev" + i).set("probetag", "dom" + i);
            model.component("comp1").probe("dom" + i).genResult(null);
        }

        model.result().dataset().create("av1", "Average");
        model.result().dataset("av1").set("intsurface", true);
        model.result().dataset("av1").set("intvolume", true);
        model.result().dataset("av1").set("data", "dset2");
        model.result().dataset("av1").set("showlevel", "off");
        model.result().dataset("av1").selection().geom("geom1", 3);
        model.result().dataset("av1").selection().set(1);
        model.result().dataset("av1").set("method", "integration");
        model.result().dataset("av1").set("intorderactive", true);
    }

    private static void configureNumericalEvaluations(Model model) {
        String[][] refConst = {% raw %}{{"solid.refpntx", "0", "\u30e2\u30fc\u30e1\u30f3\u30c8\u8a08\u7b97\u306b\u95a2\u3059\u308b\u53c2\u7167\u70b9 (x \u5ea7\u6a19)"},
                              {"solid.refpnty", "0", "\u30e2\u30fc\u30e1\u30f3\u30c8\u8a08\u7b97\u306b\u95a2\u3059\u308b\u53c2\u7167\u70b9 (y \u5ea7\u6a19)"},
                              {"solid.refpntz", "0", "\u30e2\u30fc\u30e1\u30f3\u30c8\u8a08\u7b97\u306b\u95a2\u3059\u308b\u53c2\u7167\u70b9 (z \u5ea7\u6a19)"}}{% endraw %};

        // Max mises stress evaluations
        for (int i = 1; i < NUM_TABLES; i++) {
            String dset = "dset" + (i + 3);
            model.result().numerical("gev" + i).set("data", dset);
            model.result().numerical("gev" + i).set("probetag", "none");
            model.result().numerical("gev" + i).label("max_mises" + i);
            model.result().numerical("gev" + i).set("solrepresentation", "solnum");
            model.result().numerical("gev" + i).set("table", "tbl" + i);
            model.result().numerical("gev" + i).set("expr", new String[]{"comp1.maxop1(solid.mises)"});
            model.result().numerical("gev" + i).set("unit", new String[]{"MPa"});
            model.result().numerical("gev" + i).set("descr", new String[]{""});
            model.result().numerical("gev" + i).set("const", refConst);
            model.result().numerical("gev" + i).setResult();
        }

        // Probe evaluations
        for (int i = 1; i <= NUM_PROBES; i++) {
            model.result().numerical("pev" + i).set("looplevelinput", new String[]{"manual"});
            model.result().numerical("pev" + i).set("const", refConst);
        }
    }

    private static void exportKirchhoffStress(Model model, String file, Path output) {
        model.result().numerical().create("pev10", "EvalPoint");
        model.result().numerical("pev10").set("data", "av1");
        model.result().table().create("tbl" + (NUM_TABLES + 1), "Table");
        model.result().table("tbl" + (NUM_TABLES + 1)).set("tablebuffersize", 1000000);
        model.result().table("tbl" + (NUM_TABLES + 1)).comments("Engineering Stress");

        String[] stressComponents = {"-solid.PxX", "-solid.PyX", "-solid.PzX",
                                     "-solid.PxY", "-solid.PyY", "-solid.PzY",
                                     "-solid.PxZ", "-solid.PyZ", "-solid.PzZ"};

        for (int i = 0; i < stressComponents.length; i++) {
            model.result().numerical("pev10").setIndex("expr", stressComponents[i], i);
            model.result().numerical("pev10").setIndex("unit", "MPa", i);
        }

        model.result().numerical("pev10").set("table", "tbl" + (NUM_TABLES + 1));
        model.result().numerical("pev10").setResult();
        model.result().table("tbl" + (NUM_TABLES + 1)).set("storetable", "inmodel");
        model.result().export().create("table1", "tbl" + (NUM_TABLES + 1), "Table");
        model.result().export("table1").set("filename", output + "/" + file + "_kirchhoff.txt");
        model.result().export("table1").run();
    }

    private static void exportMaxMisesStress(Model model, String file, Path output) {
        model.result().table().create("tbl" + (NUM_TABLES + 2), "Table");
        model.result().table("tbl" + (NUM_TABLES + 2)).set("tablebuffersize", 10000000);

        for (int i = 1; i < NUM_TABLES; i++) {
            model.result().numerical("gev" + i).set("table", "tbl" + (NUM_TABLES + 2));
            if (i == 1) {
                model.result().numerical("gev" + i).setResult();
            } else {
                model.result().numerical("gev" + i).appendResult();
            }
            model.result().table("tbl" + (NUM_TABLES + 2)).setIndex("headers", "max_mises" + i, i, 1);
        }

        model.result().table("tbl" + (NUM_TABLES + 2)).set("storetable", "inmodel");
        model.result().export().create("table2", "tbl" + (NUM_TABLES + 2), "Table");
        model.result().export("table2").set("filename", output + "/" + file + "_maxmises.txt");
        model.result().export("table2").run();
    }

    private static void setupVisualization(Model model, String file, Path output) {
        // Stress visualization
        model.result().create("pg2", "PlotGroup3D");
        model.result("pg2").set("data", "dset2");
        model.result("pg2").create("surf1", "Surface");
        model.result("pg2").feature("surf1").set("expr", "solid.mises");
        model.result("pg2").feature("surf1").create("def", "Deform");

        model.result("pg2").label("\u5fdc\u529b (solid)");
        model.result("pg2").set("titletype", "custom");
        model.result("pg2").set("typeintitle", false);
        model.result("pg2").set("descriptionintitle", false);
        model.result("pg2").set("expressionintitle", true);
        model.result("pg2").set("showlegendsmaxmin", true);
        model.result("pg2").feature("surf1").set("unit", "MPa");
        model.result("pg2").feature("surf1").set("const", new String[][]{
            {"solid.refpntx", "0", "\u30e2\u30fc\u30e1\u30f3\u30c8\u8a08\u7b97\u306b\u95a2\u3059\u308b\u53c2\u7167\u70b9 (x \u5ea7\u6a19)"},
            {"solid.refpnty", "0", "\u30e2\u30fc\u30e1\u30f3\u30c8\u8a08\u7b97\u306b\u95a2\u3059\u308b\u53c2\u7167\u70b9 (y \u5ea7\u6a19)"},
            {"solid.refpntz", "0", "\u30e2\u30fc\u30e1\u30f3\u30c8\u8a08\u7b97\u306b\u95a2\u3059\u308b\u53c2\u7167\u70b9 (z \u5ea7\u6a19)"}
        });
        model.result("pg2").feature("surf1").set("colortable", "RainbowLight");
        model.result("pg2").feature("surf1").set("resolution", "normal");
        model.result("pg2").feature("surf1").feature("def").set("scaleactive", true);

        // Probe plot
        model.result().create("pg3", "PlotGroup1D");
        model.result("pg3").set("probetag", "window1");
        model.result("pg3").create("tblp1", "Table");
        model.result("pg3").feature("tblp1").set("probetag", "dom1,dom2,dom3,dom4,dom5,dom6,dom7,dom8,dom9");
        model.result("pg3").set("ylog", true);
        model.result("pg3").set("showmanualgrid", true);
        model.result("pg3").set("showxspacing", true);
        model.result("pg3").set("showyspacing", false);
        model.result("pg3").set("showsecyspacing", false);
        model.result("pg3").set("showsecyextra", false);
        model.result("pg3").set("window", "window1");

        // Export animations
        exportAnimations(model, file, output);
    }

    private static void exportAnimations(Model model, String file, Path output) {
        model.result().export().create("anim1", "Animation");
        model.result().export("anim1").set("plotgroup", "pg2");
        model.result().export("anim1").set("target", "file");
        model.result().export("anim1").set("maxframes", MAX_ANIMATION_FRAMES);
        model.result().export("anim1").set("fps", ANIMATION_FPS);

        for (int ani = 1; ani < NUM_TABLES; ani++) {
            model.result().export("anim1").setIndex("singlelooplevel", ani, 1);
            String gifFile = output + "/" + file + "_e" + ani + ".gif";
            model.result().export("anim1").set("giffilename", gifFile);
            model.result().export("anim1").run();
        }

        model.result().export("anim1").set("target", "player");
        model.result().export("anim1").showFrame();
    }

    public static void main(String[] args) {
        run();
    }

    /* ========== Utility Methods ========== */

    private static double[][] basis(double aa, double bb, double cc, double bc, double ca, double ab) {
        double alpha = Math.toRadians(bc);
        double beta = Math.toRadians(ca);
        double gamma = Math.toRadians(ab);

        double[][] e = new double[3][3];
        e[0][0] = aa; e[0][1] = 0; e[0][2] = 0;
        e[1][0] = bb * Math.round(Math.cos(gamma) * ROUND_PRECISION) / ROUND_PRECISION;
        e[1][1] = bb * Math.round(Math.sin(gamma) * ROUND_PRECISION) / ROUND_PRECISION;
        e[1][2] = 0;
        e[2][0] = cc * Math.round(Math.cos(beta) * ROUND_PRECISION) / ROUND_PRECISION;
        e[2][1] = cc * Math.round(((Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma)) * ROUND_PRECISION) / ROUND_PRECISION;
        e[2][2] = cc * Math.round(Math.pow((1 - Math.pow(Math.cos(alpha), 2) - Math.pow(Math.cos(beta), 2) - Math.pow(Math.cos(gamma), 2) + 2 * Math.cos(alpha) * Math.cos(beta) * Math.cos(gamma)), (1 / 2)) / Math.sin(gamma) * ROUND_PRECISION) / ROUND_PRECISION;

        return e;
    }

    private static double[][] lattice_points(double[][] e, double[][] loc, int nx, int ny, int nz) {
        double[][] points = new double[0][3];

        for (int k = 0; k < nz; k++) {
            for (int j = 0; j < ny; j++) {
                for (int i = 0; i < nx; i++) {
                    for (double[] l : loc) {
                        double[] point = new double[3];
                        for (int m = 0; m < 3; m++) {
                            point[m] = (l[0] + i) * e[0][m] + (l[1] + j) * e[1][m] + (l[2] + k) * e[2][m];
                        }
                        points = add(points, point);
                    }
                }
            }
        }
        return points;
    }

    private static double[][][] select_bonds(double[][] points, double dMin, double dMax) {
        double[][][] lines = new double[0][2][3];

        for (int i = 0; i < points.length; i++) {
            for (int j = i + 1; j < points.length; j++) {
                double[] p = points[i];
                double[] q = points[j];
                double d = Math.sqrt(Math.pow(p[0] - q[0], 2) + Math.pow(p[1] - q[1], 2) + Math.pow(p[2] - q[2], 2));
                if ((d > dMin) && (d < dMax)) {
                    lines = add_line(lines, p, q);
                }
            }
        }
        return lines;
    }

    private static double[][] add(double[][] list, double[] a) {
        int i = list.length;
        double[][] copy = new double[i + 1][];
        System.arraycopy(list, 0, copy, 0, i);
        copy[i] = a;
        return copy;
    }

    private static double[][][] add_line(double[][][] list, double[] p, double[] q) {
        int n = list.length;
        double[][][] copy = new double[n + 1][2][3];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 2; j++) {
                System.arraycopy(list[i][j], 0, copy[i][j], 0, 3);
            }
        }

        copy[n][0] = p;
        copy[n][1] = q;
        return copy;
    }

    private static double[][] unit_tensor(double[][] a) {
        double[] l = new double[3];
        double[][] b = new double[3][3];

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                l[i] += Math.pow(a[i][j], 2);
            }
        }

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                b[i][j] = a[i][j] / Math.sqrt(l[i]);
            }
        }

        return b;
    }

    private static double[][] transpose(double[][] a) {
        double[][] b = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                b[i][j] = a[j][i];
            }
        }
        return b;
    }

    private static double[][] rot(double[][] a, double[][] b) {
        double[][] rot = new double[0][3];

        for (int i = 0; i < b.length; i++) {
            double[] r = {0, 0, 0};
            for (int j = 0; j < a.length; j++) {
                for (int k = 0; k < 3; k++) {
                    r[j] += a[k][j] * b[i][k];
                }
            }
            rot = add(rot, r);
        }

        return rot;
    }

    private static double[][] translatePoints(double[][] points, double dis) {
        double[][] p = new double[points.length][3];
        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points[i].length; j++) {
                p[i][j] = (points[i][j] + dis) % 1;
            }
        }
        return p;
    }
}
